Unity3D 编辑器及扩展

		Glossary 术语
	1. GameObject
	2. MonoBehaviorr/Component
	3. Inspector
	4. Field
	5. Property


Serializable Classes
		可以轻松地组织、封装和包数据(Can be used to easily organize, encapsulate, and package data)

[Serializable]
public class PlayerStates {
	public float moveSpeed = 1.0f;
	public float turnSpee = 90.0f;
}


用注解方式，标记一个类的方法或变量 （Ways to tag a class or variable with a piece of data）

序列化是其中之一 （[Serializable] from the last example is one of them!）

Unity提供了几个检查员相关的属性 （Unity provides several inspector-related Attributes）


http://docs.unity3d.com/Manual/Attributes.html

[SerializeField]		将不会被序列化的非公共变量可以序列化，这么在下次读取时，就是上次赋值的值。
[HideInInspector]		使用了该属性的变量不显示在inspector 但是被序列化。即不会显示，也不会被外部类调用。
[ExecuteInEditMode()]：这个函数可以使代码在编辑模式下运行，不需要运行游戏；
[ExecuteInEditMode]：　编辑环境中该功能（类）生效，简单讲就是。不运行游戏。就可你让你的功能起作用，比如：NGUI中的Slider
[MenuItem("")]：导航条中加入自定义菜单。可参考：xiaobao1993.com/121.html
[CustomEditor(typeof(EButton))]：绑定使用该类。必须依赖EButton类。参考：xiaobao1993.com/272.html
[RequireComponent (typeof (ClassName))]：添加该类时。自动会加入ClassName类。
[ContextMenu ("XXX")]：加入Inspector面板右键菜单。点击执行该功能。
[ContextMenuItem(,)]
[Multiline()]
[Range(,)]
[Space()]
[TextArea(,)]
[Header()]
[Tooltip()]
[AddComponentMenu("XXX/XX/XXX")]：菜单中出现定义的该类。




[HideInInspector]用法：
正常情况下我们这样定义变量。如下：


public int index;
这样。我们在Inspector是能看到index变量的。

如果我们要他不再Inspector显示。


[HideInInspector]
public int index;
这样就不能在Inspector中看到。不能手动赋值了。

[SerializeField]用法：

正常情况下我们定义的私有变量在Inspector中我们是不能看到并且手动赋值了。 如果要就可以用[SerializeField]了。如下


[SerializeField]
private int index;
这样即使是私有变量。我们也能在编辑时。在Inspector中赋值了。



using UnityEngine;
using System.Collections;
using UnityEditor;
using System.IO;
public class TestEditor
{
    //%代表ctrl，#代表Shift，&代表Alt
    [MenuItem("Plugin/测试菜单添加1级 %#o")]
    public static void TestMenu1()
    {
        Test1();
    }
   [MenuItem("Plugin/测试菜单2/测试菜单2级目录1 %#f")]
   public static void TestMenu2()
   {
        Test2();
   }
   [MenuItem("Plugin/测试菜单2/测试菜单2级目录2 %#f")]
   public static void TestMenu3()
   {
        Test3();
   }
 
}